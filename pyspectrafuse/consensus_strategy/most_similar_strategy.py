from typing import Tuple
from pyspectrafuse.consensus_strategy.consensus_strategy_base import ConsensusStrategy
import pandas as pd
import numpy as np
import logging
import functools
from pyspectrafuse.consensus_strategy.metrics import dot

logging.basicConfig(format="%(asctime)s [%(funcName)s] - %(message)s", level=logging.DEBUG)
logger = logging.getLogger(__name__)


class MostSimilarStrategy(ConsensusStrategy):

    def __init__(self, sim='dot', fragment_mz_tolerance=0.02):
        self.fragment_mz_tolerance = 0.02
        self.sim = sim
        if self.sim == 'dot':
            self.compare_spectra = functools.partial(
                dot, fragment_mz_tolerance=fragment_mz_tolerance)
        else:
            raise ValueError("Unknown spectrum similarity method")

    def consensus_spectrum_aggregation(self, cluster_df: pd.DataFrame,
                                       filter_metrics='global_qvalue') -> Tuple[pd.DataFrame, pd.DataFrame]:
        """
        This method calculates similarity distances between each spectrum in a cluster and all other spectra
        in the cluster, sums the similarity distances, and selects the spectrum with the maximum sum as
        the representative spectrum. When multiple spectra have the same sum, MOST randomly selects one
        as the representative. The consensus spectrum generated by this algorithm comes from the spectrum
        itself, similar to the BEST algorithm, and does not generate a new spectrum.
        """
        if self.sim == 'dot':
            merge_median_and_top, single_spectrum_df = self.classify_cluster_group(cluster_df, filter_metrics)

            merge_median_and_top['ms2spectrumObj'] = merge_median_and_top.apply(
                lambda row: self.get_Ms2SpectrumObj(row),
                axis=1)
            # Group by accession and apply selection function to each group
            res = merge_median_and_top.groupby('cluster_accession').apply(self._select_representative)
            logger.info(
                f"consensus spectrum shape: {res.shape} ; single spectrum shape: {single_spectrum_df.shape}")

            return res, single_spectrum_df

    def _select_representative(self, single_group: pd.DataFrame) -> pd.Series:
        # Create a dictionary for a cluster, key is usi, value is sus.MsmsSpectrum object
        cluster_spectra = single_group.set_index('usi')['ms2spectrumObj'].to_dict()
        spectra_keys = list(cluster_spectra.keys())

        sim_matrix = np.zeros((len(spectra_keys), len(spectra_keys)))
        for i in range(len(spectra_keys)):
            for j in range(i, len(spectra_keys)):
                # Pass two spectra and use dot product to calculate similarity (spectra can be the same)
                sim_matrix[i, j] = sim_matrix[j, i] = self.compare_spectra(
                    cluster_spectra[spectra_keys[i]],
                    cluster_spectra[spectra_keys[j]])
        # Find the spectrum with the maximum similarity to all other spectra.
        max_sim_index = sim_matrix.sum(axis=0).argmax()
        max_sim_spectrum = cluster_spectra[spectra_keys[max_sim_index]]
        max_sim_usi = spectra_keys[max_sim_index]

        # Find and return the row corresponding to the most similar spectrum
        max_sim_row = single_group[single_group['usi'] == max_sim_usi]
        return max_sim_row
